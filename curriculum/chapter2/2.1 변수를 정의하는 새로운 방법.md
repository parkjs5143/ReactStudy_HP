# 변수를 정의하는 새로운 방법

기록일: 2022년 2월 16일
상태: ES6+ 자바스크립트
장: 2.1장

# 변수를 정의하는 새로운 방법 : const, let

ES5 까지는 변수를 var만 이용해 정의했고 그게 유일한 방법이었다. 지금부터 var 의 문제점을 살펴보고 ES6 부터 지원되는 const 와 let 이 문제를 어떻게 해결하는지 살펴보자.

---

# var가 가진 문제

1. 함수 스코프
    1. 함수 내부에서 var 키워드를 사용하지 않고 변수에 값을 할당하면 전역변수가 된다.
    2. for 문에서 정의된 변수가 반복문이 끝난 이후에도 계속 남아 있음.
    3. 해결을 위해, 즉시 실행 함수를 사용하기도 하지만, 작성이 번거롭고 가독성이 떨어진다.
2. 호이스팅
    1. 변수가 정의된 시점보다 먼저 변수를 사용할 수 있음.
        
        : 변수의 정의만 끌어올려지고 값은 원래 정의했던 위치에서 할당되기 때문
        
    2. 변수가 정의된 시점보다 먼저 변수에 값을 할당할 수 있음.
        
        i = 1; var i = 2;
        
3. 정의된 변수를 다시 재 정의할 수 있음.
    
    var myVar = 1; var myVar = 2;
    
4. 상수처럼 쓸 값도 무조건 재할당 가능 변수로 만들어야 한다.

---

# var의 문제를 해결하는 const, let

1. const 와 let 은 블록 스코프
    1. 블록을 벗어나면 변수를 사용할 수 없다.
    2. 같은 이름을 갖고 다른 블록에 정의된 변수를 사용할 경우 블록마다 다른 값을 가진다.
2. const 와 let 에서의 호이스팅
    1. const와 let 으로 정의된 변수를 정의하기 전에 사용할 수 없다.
        
        정의된 위치와 호이스팅 된 위치 사이에서 변수를 사용하려고 할 때
        
        ⇒ TDZ(temporal dead zone에 해당)
        
    2. 호이스팅은 스코프 단위로 일어나기 때문에 아래 코드는 참조 에러 발생
        
        ```jsx
        const foo = 1;
        {
        	console.log(foo);   // 참조 에러 (TDZ에 해당)
        	const foo = 2;
        }
        ```
        
    
    ### const 는 변수를 재할당 불가능하게 만든다.
    
    1. const 로 선언된 변수에는 값을 재할당할 수 없다. (let 과 var는 가능)
    2. const 로 선언해도 객체 내부 속성값은 수정 할 수 있음.
        
        ⇒ 객체는 값을 가지지 않으며, 값을 참조하는 것이기 때문.
        
        만약, 객체의 내부 속성값도 수정 불가능하게 하고 싶을 경우
        
        1. immer, immutable.js 의 외부패키지 사용
            
            객체를 수정하려 할 때 기존 객체는 변경하지 않고 새 객체를 생성한다.
            
            이는 불변성의 법칙을 지키기 위함, 리액트에서 객체 내부의 값이 업데이트 되어도 인지하지 못하기 때문.
            
            - immutable.js **:** 자바스크립트 기본 객체를 사용하지 않고 ****Object 대신 Map**,** Array 대신 List를 사용.
            - immer : 자바스크립트 기본 객체를 사용, [Proxy](https://velog.io/@longroadhome/%EB%AA%A8%EB%8D%98JS-Proxy%EC%99%80-Reflect) 객체를 이용하는 함수를 통해 업데이트.
        2. 자바스크립트 내장 함수 사용 
            
            Object.preventExtensions() : 객체를 확장할 수 없다. 내부 속성을 수정, 삭제는 가능하다.
            
            Object.seal() : 객체를 봉인하여 내부 속성을 추가, 삭제 할 수 없게 한다. 이미 있는 속성에 대해서는 수정할 수 있다.
            
            Object.freeze() : 객체를 동결 시킨 후 내부 속성을 추가, 수정, 삭제 할 수 없게 만든다.
            
    
    ---